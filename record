1. Mapper 에서 <![CDATA[ 와 ]]> 를 통해 sql문을 감싸는 것은 쿼리문 안에서 > , < , & 표기를 태그로 인식하는 것을 피하기 위해 사용.

2. Mapper 에서 resultMap 을 사용하는 경우는 Java 객체의 변수명과 DB column 명이 다를 경우이다.
 - 여기서는 글작성일(regdate) 와 조회수(viewcnt) 부분이 DB상에는 소문자이나 ArticleDto 에서는 카멜표기법으로 (regDate, viewCnt) 사용되어
 쿼리 조회시 오류를 피하기 위해 사용했다. = resultMap을 통해 Java변수명과 DB column명을 일치시켜주고 select쿼리의 resultType 속성 대신 resultMap을 사용한다.
 
 
 3. 게시판 테이블 생성 sql
 
 - article_no : 게시글 번호
 - title : 게시글 제목
 - content : 게시글 내용
 - writer : 게시글 작성자
 - regdate : 게시글 등록일
 - viewcnt : 게시글 조회수
 - reply_cnt : 댓글 갯수
 

 CREATE TABLE tbl_article (
  article_no INT NOT NULL AUTO_INCREMENT,
  title VARCHAR(200) NOT NULL,
  content TEXT NULL,
  writer VARCHAR(50) NOT NULL,
  regdate TIMESTAMP NOT NULL DEFAULT NOW(),
  viewcnt INT DEFAULT 0,
  PRIMARY KEY (article_no)
)
 
 ALTER TABLE tb_article add column reply_cnt int default 0;
 
 4. 댓글 테이블 생성 sql 과 참조키 설정
 
 - reply_no : 댓글 번호
 - article_no : 댓글이 물고있어야하는 게시글 번호
 - reply_text : 댓글 내용
 - reply_writer : 댓글 작성자
 - reg_date : 댓글 등록일
 - update_date : 댓글 갱신일
 
 CREATE TABLE tbl_reply (
  reply_no INT NOT NULL AUTO_INCREMENT,
  article_no INT NOT NULL DEFAULT 0,
  reply_text VARCHAR(1000) NOT NULL,
  reply_writer VARCHAR(50) NOT NULL,
  reg_date TIMESTAMP NOT NULL DEFAULT NOW(),
  update_date TIMESTAMP NOT NULL DEFAULT NOW(),
  PRIMARY KEY (reply_no)
);

ALTER TABLE tbl_reply ADD CONSTRAINT FK_ARTICLE
FOREIGN KEY (article_no) REFERENCES tbl_article (article_no);
 

 5. 회원 테이블 생성 sql
 
 - user_id : 회원아이디
 - user_pw : 비밀번호
 - user_name : 이름
 - user_email : 이메일
 - user_point : 회원포인트
 - session_key : 로그인유지를 위한 세션키
 - session_limit : 로그인유지를 위한 세션리밋
 - user_img : 회원프로필 이미지
 - user_join_date : 가입일자
 - user_login_date : 로그인일자
 - user_signature : 서명
 
 CREATE TABLE tbl_user (
  user_id VARCHAR(50) NOT NULL,
  user_pw VARCHAR(100) NOT NULL,
  user_name VARCHAR(100) NOT NULL,
  user_email VARCHAR(50) NOT NULL,
  user_point INT NOT NULL DEFAULT 0,
  session_key VARCHAR(50) NOT NULL DEFAULT 'none',
  session_limit TIMESTAMP,
  user_img VARCHAR(100) NOT NULL DEFAULT 'user/default-user.png',
  user_join_date TIMESTAMP NOT NULL DEFAULT NOW(),
  user_login_date TIMESTAMP NOT NULL DEFAULT NOW(),
  user_signature VARCHAR(200) NOT NULL DEFAULT '안녕하세요 ^^',
  PRIMARY KEY (user_id)
);


6. 비밀번호를 암호화 처리하기 위해서는 BCrypt를 사용해야하며 이를 위해선 pom.xml에 의존성 추가가 필요하다.
<!--비밀번호 암호화 -->
<!-- https://mvnrepository.com/artifact/org.mindrot/jbcrypt -->
<dependency>
    <groupId>org.mindrot</groupId>
    <artifactId>jbcrypt</artifactId>
    <version>0.4</version>
</dependency>

7. BCrypt.hashpw()  메서드
BCrypt.hashpw( 첫번째파라미터 : 암호화할 비밀번호 , 두번째파라미터 : BCrypt.gensalt() ) = 암호화된 비밀번호 반환

8. LoginInterceptor 클래스를 Spring에서 인터셉터로 인식시키기 위해 servlet-context.xml 에 추가가 필요하다.
	<beans:bean id="loginInterceptor" class="com.oyster.myboard.commons.interceptor.LoginInterceptor"/>
	
	<interceptors>
	    <interceptor>
	      <mapping path="/user/loginPost"/>
	      <beans:ref bean="loginInterceptor"/>
	    </interceptor>
	</interceptors>
	
9. Interceptor를 생성하여 이를 활용하고자 할 때 생성한 인터셉터클래스는 servlet-context.xml에 빈을 등록해줘야 이를 Spring에서 인식하고 동작한다.

